using Application.Common.Interfaces;
using Application.Common.Interfaces.Repositories;
using Application.TestSessions.Exceptions;
using Domain.Audit;
using Domain.Tests;
using LanguageExt;
using MediatR;

namespace Application.TestSessions.Commands;

/// <summary>
/// Команда для повторного відкриття тесту конкретному студенту.
/// Дозволяє викладачу надати додаткову спробу без зміни налаштувань тесту.
/// Попередні спроби зберігаються як окремі записи для історії.
/// </summary>
public record ReopenTestSessionCommand : IRequest<Either<TestSessionException, TestSession>>
{
    /// <summary>
    /// ID тесту для повторного відкриття.
    /// </summary>
    public required Guid TestId { get; init; }
    
    /// <summary>
    /// ID студента, якому надається додаткова спроба.
    /// </summary>
    public required Guid StudentId { get; init; }
    
    /// <summary>
    /// Причина повторного відкриття (для аудіту).
    /// </summary>
    public string? Reason { get; init; }
}

public class ReopenTestSessionCommandHandler(
    ITestSessionRepository sessionRepository,
    ITestRepository testRepository,
    IApplicationDbContext dbContext,
    IAuditService auditService,
    ICurrentUserService currentUserService,
    IPublisher publisher)
    : IRequestHandler<ReopenTestSessionCommand, Either<TestSessionException, TestSession>>
{
    public async Task<Either<TestSessionException, TestSession>> Handle(
        ReopenTestSessionCommand request,
        CancellationToken cancellationToken)
    {
        var testId = new TestId(request.TestId);
        var testOption = await testRepository.GetByIdAsync(testId, cancellationToken);

        if (testOption.IsNone)
        {
            return new TestSessionNotFoundException(TestSessionId.Empty());
        }

        var test = testOption.IfNone(() => throw new InvalidOperationException());

        // Перевіряємо чи є активна сесія
        var activeSession = await sessionRepository.GetActiveSessionAsync(testId, request.StudentId, cancellationToken);
        if (activeSession.IsSome)
        {
            return new TestSessionAlreadyExistsException(testId, request.StudentId);
        }

        return await CreateReopenedSession(testId, request.StudentId, test, request.Reason, cancellationToken);
    }

    private async Task<Either<TestSessionException, TestSession>> CreateReopenedSession(
        TestId testId,
        Guid studentId,
        Test test,
        string? reason,
        CancellationToken cancellationToken)
    {
        try
        {
            var contentJson = System.Text.Json.JsonSerializer.Deserialize<TestContentDto>(test.ContentJson);
            var questions = contentJson?.Questions ?? new List<QuestionDto>();

            int maxScore;
            if (test.Settings.BankModeQuestionCount.HasValue &&
                test.Settings.BankModeQuestionCount.Value > 0 &&
                test.Settings.BankModeQuestionCount.Value < questions.Count)
            {
                maxScore = questions
                    .Take(test.Settings.BankModeQuestionCount.Value)
                    .Sum(q => q.Points);
            }
            else
            {
                maxScore = questions.Sum(q => q.Points);
            }

            // Створюємо НОВУ сесію (попередні залишаються в історії)
            var session = TestSession.New(testId, studentId, maxScore);

            sessionRepository.Add(session);
            await dbContext.SaveChangesAsync(cancellationToken);

            // Логуємо дію повторного відкриття
            await auditService.LogAsync(
                "SESSION_REOPENED",
                "TestSession",
                session.Id.Value.ToString(),
                oldValues: new { StudentId = studentId, Reason = reason },
                newValues: new { SessionId = session.Id.Value },
                cancellationToken: cancellationToken);

            // Публікуємо подію для SignalR сповіщення
            await publisher.Publish(new Events.TestSessionStartedEvent
            {
                SessionId = session.Id.Value,
                TestId = testId.Value,
                UserId = studentId,
                StartedAt = session.StartedAt
            }, cancellationToken);

            return session;
        }
        catch (Exception exception)
        {
            return new UnhandledTestSessionException(TestSessionId.Empty(), exception);
        }
    }
}
